# Создание приложения для голосования с токенами ERC20. 

## 0 Вступление 

Сегодня многие компании испытывают потребность в финансировании на новые или текущие проекты. 
Кредит по высокой ставке и под залог имущества может оказаться для бизнеса слишком тяжелой ношей.  
Крупные компании могут позволить себе выпуск акций через процедуру [IPO](https://journal.tinkoff.ru/guide/what-is-ipo/). 
Однако размещение на фондовом рынке — это дорогой и сложный процесс с множеством участников и регуляторов. 
С помощью технологии блокчейна компании могут привлечь инвестиции быстро, анонимно и без лишних юридических сложностей. 
Однако процедуры [ICO, IDO, IEO](https://journal.tinkoff.ru/ico-ido-ieo/) не защищают инвестора от скама, так как это происходит при торговле на фондовом рынке. 
Тем не менее, если компания имеет хорошую репутацию, она может рассчитывать на финансовую поддержку со стороны инвесторов. 
А инвесторам, с другой стороны, нужно соблюдать главный принцип со времен Вавилона - вкладывать деньги только в то, в чем хорошо разбираешься.  

Итак, в этом уроке мы сделаем приложение для управления публичной компанией с использованием токенов сети Ethereum.  
Любой желающий, имеющий специальные токены, сможет принять участие в голосовании по ключевым вопросам, связанными с управлением компанией. 
Вес его голоса будет определяеться количеством токенов на счету аккаунта в блокчейне. 
А сами вопросы и результаты голосования будут храниться в традиционной базе данных.  

### План работы:
1. Размещение смарт-контракта в тестовой сети sepolia с помощью инструмента web3gate. 
2. Разработка пользовательского интерфейса с помощью шаблона ScaffoldEth2. 
3. Разработка моделей данных и наполнение таблиц SQL.  
4. Подключение блокчейна на серверной части приложения. 
5. Покупка токенов и тестирование приложения. 


## 1 Размещение смарт-контракта в тестовой сети с помощью web3gate 

Давайте рассмотрим, как с помощью инструмента Web3gate можно выпустить свою собственную монету в формате токенов ERC20.
По своей сути ERC20 это спецификация, которая определяет главное свойство токенов - их взаимозаменяемость. 
То есть, что это может быть? 
Давайте обратимся к [документации](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/).
Токены ERC20 могут быть очками репутации на некоторой платформе. 
Например, это может быть профессиональный форум, где люди высказываются по тем или иным вопросам. 
Репутация человека может расти или падать в зависимости от того, что этот человек пишет на форуме. 
Токенами могут быть очки опыта в онлайн игре. При этом на блокчейне все могут видеть, за какие задания игрок получил тот или иной опыт.  
Но самое интересное, что токенами могут быть финансовые активы реального мира. 
Это может быть любая ценность, например, доллар, унция золота или доля в компании. 
Главное свойство токена ERC20 состоит в том, что он целиком или его часть являются такими же стандартными и взаимозаменяемыми, как и все остальные другие части. 
Не имеет значение, каким образом аккаунт получил один токен - целиком в одной транзакции или в двух транзакциях по пол-токена.  
Этим ERC20 кардинально отличается от NFT, в котором каждый токен является уникальным.  

Итак, спецификация ERC20 реализуется с помощью смарт-контракта, работающего на блокчейне. 
Этот смарт-контракт должен реализовывать несколько основных функций, призванных обеспечить безопасную и прозрачную передачу токенов от одного аккаунта к другому. 
Давайте рассмотрим эти методы.  

Метод Name возвращает тип данных string, это полное имя токена. 
Метод Symbol также возвращает строку, это компактное и желательно уникальное имя токена.
Метод Decimals возвращает то количество десятичных цифр, которое идет после запятой в токене. 
Мы знаем, что смарт-контракты оперируют только с целочисленной арифметикой. 
Эта особенность нужна для того, чтобы избежать проблем с накоплением ошибки округления.
Если мы хотим иметь возможность дробить наши токены, то при создании смарт-контракта в конструкторе нужно указать, сколько чисел после запятой будет содержать наш токен. 
По умолчанию это количество равно восемнадцать, по аналогии с нативной криптовалютой Ethereum и ее минимальной дискретной единицей wei. 
То есть наш токен по умолчанию можно делить вплоть до восемнадцати знаков после запятой. 
Если мы хотим оперировать только с целочисленными монетами, то при создании токена нам нужно указать в качестве параметра Decimals 0. 
Тогда у нас после запятой никаких значений не будет, будут только целочисленные токены. 
Метод Total Supply возвращает количество токенов, созданных при размещении в сети смарт-контракта, т.е. сколько всего токенов было выпущено. 
Метод Balance Off имеет входящий параметр owner, это адрес произвольного аккаунта. 
На выходе мы получаем количество токенов, закрепленных за данным аккаунтом. 
При этом результат мы получаем в мельчайших единицах, его нужно умножать на 10 в степени decimals.  

Перечисленные методы имеют модификатор View, то есть за их выполнение не нужно платить GAS. 
Транзакции бесплатные, они просто читают состояние блокчейна и никаких изменений в него не вносят. 
Методы, которые не имеют модификатора View изменяют состояние блокчейна и позволяют совершать следующие операции.
Первый платный метод это Transfer - передача токенов от аккаунта from, который владеет токеном на определенный адрес to определенного количества мельчайших дискретных величин value. 
Возвращает этот метод значение типа bool, True в случае успешного выполнения транзакции. 
С помощью метода Approve можно выдавать права на распоряжение токенами. 
То есть тот аккаунт, который владеет правом распоряжаться токенами, может перемещать их с помощью метода Transfer. 
Метод Approve позволяет наделить произвольный аккаунт спендер правом распоряжаться некоторым количеством токенов равное value. 
При успешном выполнении операции тоже возвращается значение типа bool.
И, наконец, метод Allowance позволяет прочитать, сколько дозволено перевести адресу Owner в отношении адреса Spender, сколько количество токенов может быть переведено.

Также стандарт ERC20 определяет два события. 
Событие Transfer срабатывает при передаче токенов и событие Approval при наделении адреса правом распоряжаться токенами.  

Дальше идет важное замечание по поводу процедуры получения токенов. 
Дело в том, что все адреса в сети Ethereum делятся на два вида - под управлением человеком и под управлением смарт-контрактом. 
Так вот если на адрес под управлением смарт-контракта перевести некоторое количество токенов, то возникает две проблемы. 
Во-первых нет механизма, который позволяет отследить получение токенов.
А во-вторых, аккаунт под управлением смарт-контракта не сможет распорядиться токенами, если у него нет соответствующих методов для работы с ними.
Для решения этой проблемы был разработан улучшенный стандарт ERC223. 
Если эти проблемы являются критичными, то нужно рассмотреть формат токенов.  

Более подробную спецификацию можно почитать в разделе [EIPS](https://eips.ethereum.org/EIPS/eip-20). 
Здесь тоже самое, перечисленные методы и с пояснениями, как эти методы должны работать и как должны инициироваться события. 
И приведена ссылка на две реализации. 
Стандарт определяет нам только функционал токенов, а то, как мы будем реализовывать с помощью языка Solidity или с помощью другого языка этот стандарт нам не регламентирует.  
Мы используем пример от компании OpenZeppelin, которая достаточно давно работает в этой сфере.  
У нее есть достаточно эффективная и безопасная реализация токена ERC20 на языке Solidity. 

На странице [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol) можно почитать исходный код, как этот функционал реализуется на языке Solidity.  

Давайте перейдем к практике. 
На странице портала [Web3gate](https://www.web3gate.ru/en/lk/projects), на вкладке Project Overview кликаем кнопку Remix IDE. 
В папке Contracts мы создаем новый файл. 
Допустим, я как владелец компании Rostelecom хочу выпустить монеты под названием RTC test coin. 
Я наследуюсь от `ERC20`, поэтому практически никакого кода писать не нужно.  
Нужно лишь указать правильную версию компилятора, импортировать реализацию от OpenZeppelin, она уже интегрирована в Remix. 
Далее определить название монеты, название контракта и в конструкторе указать Initial Supply, начальное количество токенов, которые я хочу выпустить на блокчейне в своем смарт-контракте, название NAME и символ. 
Rostelecom coin это полное название монеты и краткое название RTC. 
При вызове конструктора вызывается метод mint, в котором указывается владелец смарт-контракта. 
Это будет мой аккаунт, который я буду использовать при размещении, но здесь можно указать и любой другой адрес. 
Кроме того, начальное количество монет умножено на 10 в 18 степени. 
По умолчанию децимал дает 18 знаков после запятых, я оставлю это значение по умолчанию. 

То есть, если мы издаем одну монету, то внутри смарт-контракт переменная будет хранить большое число 10 в 18 степени. 
Если мы захотим взять 0,1 токена, то фактически мы будем иметь дело со значением 10 в 17 степени. 

Переходим на вкладку компилятора, выбираем версию 0.8.20.
Здесь у нас появилась вкладка со всеми теми контрактами, которые были использованы в реализации OpenZeppelin. 
Мы выбираем последний контракт из списка, наш контракт RTC Coin.  

Далее разместим скомпилированный контракт, но не в песочнице, не внутри браузера, а в тестовую сеть Sepolia через точку доступа Injected Web 3.
Мы используем рекомендованный кошелек MetaMask. 
В настройках кошелька в качестве точки доступа используется тот ключ API, который я создал в своем проекте.
В моем кошельке есть несколько аккаунтов. 
Активным может быть только один аккаунт, сейчас это адрес с окончанием 4010. 

Для деплоя контракта RTC Coin через Remix мне необходимо указать начальное количество монет.
Я нажимаю на кнопку Deploy и за эту операцию мне нужно заплатить довольно большую комиссию.
В кошелке указывается текущая цена настоящих монет Ethereum в основной сети. 
С учетом этой цены в основной сети мне нужно было бы заплатить за деплой смарт-контракта порядка 200 долларов или 0,06 ETH. 
Это полезно для понимания, во сколько обходится самостоятельное размещение монет в сети Ethereum.
Ждем пока транзакция пройдет. 

После размещения транзакции в блокчейне в интерфейсе Remix появился адрес экземпляра контракта RTC Coin. 
Этот адрес я могу использовать в кошельке для отображения баланса монет RTC coin. 
На вкладке токенс мы импортируем адрес контракта RTC и видим, что на счету у меня 100 монеток RTC. 
Начальное количество монет, которое я указал Initial Supply это 100, но внутри смарт-контракта хранится число равное 10 в 20 степени. 
Т.е. 100 умноженное на 10 в 18 степени.
Об этом нужно помнить, потому что в интерфейсе Remix значение Value нужно указывать именно в тех значениях, которые используются внутри смарт-контракта.  

Давайте протестируем работу методов через веб-интерфейс. 
Я беру адрес своего аккаунта и вставляю в метод BalanceOff.
У меня получилось число с 20 нулями, что соответствует целочисленному представлению токенов в блокчейне. 
Для того чтобы получить натуральное значение токенов, мне нужно возвращенное значение 10 в 20 степени разделить на 10 в степени Deсimals.
Если убрать отсюда лишние 18 нулей, то у меня получится ровно 100 токенов. 
Это и есть баланс моего аккаунта номер 1, который заканчивается на 4010. 

Давайте попробуем взять другой аккаунт который заканчивается на 3941. 
Импортируем токены и попробуем посмотреть его баланс.
На счету есть некоторое количество тестовой крипты но RTC в нем у него токенов нет.
Баланс RTC этого аккаунта равен 0.
И для того чтобы передать RTC токены, я должен вызвать метод Transfer от имени аккаунта владельца 4010.
Я хочу передать 10 монет и для этого я здесь в методе Transfer указываю Value. 
Если это делать через интерфейс Remix, то нужно указывать количество в соответствии с внутренним представлением, т.е. 10 в степени 19.
В MetaMask мы указываем натуральное количество токенов, т.к. кошелек уже прочитал свойство Decimals смарт-контракта и сам умножит на нужное значение. 

Указываем адрес и видим, что комиссия которую нужно платить за передачу токена 15 долларов.
Нажимаем подтвердить и ждем когда у нас в консоли появится сообщение об успешной передаче токенов.

Давайте посмотрим что у нас изменилось в кошельке.
Видим, у аккаунта 3941 10 RTC, а у аккаунта 4010 баланс 90 RTC.


## 2 Разработка пользовательского интерфейса для голосования 

В качестве шаблона для нашего приложения мы будем использовать (ScaffoldEth2)[]. 
Фронтенд будет на next.js, база данных для голосования - vercel postgres. 
Блокчейн - ethereum sepolia, формат токенов - ERC20. 

Клонируем репозиторий с помощью команды 
```
git clone https://github.com/labintsev/my-erc-tokens.git
``` 
Откроем папку в VsCode и установим зависимости командой 

```
yarn install
``` 
После установки зависимостей запустим локальный блокчейн командой 
```
yarn chain
``` 
Откроем новый терминал, разместим смарт-контракт и запустим фронтенд 
```
yarn deploy
yarn start
```

На главной странице добавлена карточка, которая ведет на страницу голосования. 

```html
<div className="flex flex-col bg-base-100 px-10 py-10 text-center items-center max-w-xs rounded-3xl">
  <StarIcon className="h-8 w-8 fill-secondary" />
  <p>
    <Link href="/voting" passHref className="link">
      Vote
    </Link>{" "}
    to make the company successful.
  </p>
</div>
```

## 3 Разработка моделей данных и наполнение таблиц SQL 

## 4 Подключение блокчейна на сервере

## 5 Покупка токенов и тестирование приложения
